module Main exposing (main)

import Bytes exposing (Bytes)
import Db
import Db.Encode
import HttpClient
import HttpServer exposing (Request, ServerError(..), Method(..))
import HttpServer.Response as Response exposing (Response)
import Init
import Node exposing (Environment, Program)
import Route.Error
import Route.User
import Stream
import Task exposing (Task)
import Test.E2E.Helper as Helper


main : Program Model Msg
main =
    Node.defineProgram
        { init = init
        , update = update
        , subscriptions = subscriptions
        }


config : { host : String, port_ : Int }
config =
    { host = "0.0.0.0"
    , port_ = 3000
    }


-- MODEL


type alias Model =
    { stdout : Stream.Writable Bytes
    , stderr : Stream.Writable Bytes
    , server : Maybe HttpServer.Server
    , db : Db.Connection
    }


init : Environment -> Init.Task { model : Model, command : Cmd Msg }
init env =
    Init.await HttpServer.initialize <| \serverPermission ->
    Init.await HttpClient.initialize <| \httpPerm ->
        let
            db =
                Helper.initDb httpPerm
        in
        Node.startProgram
            { model =
                { stdout = env.stdout
                , stderr = env.stderr
                , server = Nothing
                , db = db
                }
            , command =
                Cmd.batch
                    [ Db.transaction db migrations
                        |> Task.attempt DbMigrationResult
                    , HttpServer.createServer serverPermission config
                        |> Task.attempt CreateServerResult
                    ]
            }


-- UPDATE


type Msg
    = CreateServerResult (Result HttpServer.ServerError HttpServer.Server)
    | DbMigrationResult (Result Db.Error (Array Int))
    | GotRequest { request : HttpServer.Request, response : Response }
    | ResponseReady Response


update : Msg -> Model -> { model : Model, command : Cmd Msg }
update msg model =
    when msg is
        CreateServerResult result ->
            when result is
                Ok server ->
                    { model = { model | server = Just server }
                    , command = 
                        "Server started: http://" ++ config.host ++ ":" ++ String.fromInt config.port_
                            |> print model.stdout
                            |> Task.execute
                    }

                Err (ServerError { code, message }) ->
                    { model = model
                    , command =
                        "Server failed to start: " ++ code ++ "\n" ++ message
                            |> print model.stderr
                            |> Task.execute
                    }

        DbMigrationResult result ->
            when result is
                Ok numChanges ->
                    { model = model
                    , command = Cmd.none
                    }

                Err error ->
                    { model = model
                    , command =
                        -- TODO: real error message
                        "Db failed to migrate: " ++ Debug.toString error
                            |> print model.stderr
                            |> Task.andThen (\_ -> Node.exitWithCode 1)
                            |> Task.execute
                    }
                            
        GotRequest { request, response } ->
            { model = model
            , command =
                route request response
                    |> Task.perform ResponseReady
            }

        ResponseReady response ->
            { model = model
            , command =
                Response.send response
            }


route : Request -> Response -> Task Never Response
route request response =
    let
        path =
            request.url.path
                |> String.split "/"
                |> Array.keepIf (\s -> s /= "")
    in
    when { method = request.method, path = path } is
        { method = POST, path = [ "user" ] } ->
            Route.User.create response request.body

        --{ method = GET, path = [ "users", "validate" ] -> Route.user
        --{ method = GET, path = [ "sessions" ] -> Route.Session.get

        _ ->
            Route.Error.notFound response


print : Stream.Writable Bytes -> String -> Task Never {}
print stream string =
    Stream.writeLineAsBytes string stream
        |> Task.map (\_ -> {})
        |> Task.onError (\_ -> Task.succeed {})


-- SUBSCRIPTION


subscriptions : Model -> Sub Msg
subscriptions model =
    when model.server is
        Just server ->
            HttpServer.onRequest server <| \req res -> 
                GotRequest { request = req, response = res }

        Nothing ->
            Sub.none


-- TODO: move to module

migrations : Array { statement : String, parameters : Array Db.Encode.Value }
migrations =
    [ { statement = "PRAGMA foreign_keys = ON"
      , parameters = []
      }

    , { statement = "PRAGMA busy_timeout = 5000"
      , parameters = []
      }

    , { statement = 
        """
        CREATE TABLE IF NOT EXISTS user (
            id INTEGER PRIMARY KEY,
            email TEXT NOT NULL UNIQUE,
            created INTEGER NOT NULL -- timestamp
        ) STRICT
        """
      , parameters = []
      }

    , { statement =
        """
        CREATE TABLE IF NOT EXISTS session (
            id INTEGER PRIMARY KEY,
            created INTEGER NOT NULL,
            user_id INTEGER NOT NULL REFERENCES user(id),

            -- Token used in email validation link.
            validation_token TEXT NOT NULL UNIQUE,

            -- Create and show this when user follows email validation link.
            -- User will provide this to the CLI.
            validation_code TEXT UNIQUE,

            -- Token used by the CLI to fetch session token.
            fetch_session_token TEXT NOT NULL UNIQUE,

            -- Create and return this when CLI posts with validation_code and fetch_session_token
            session_token TEXT UNIQUE
        ) STRICT
        """
      , parameters = []
      }

    , { statement =
        """
        CREATE TABLE IF NOT EXISTS publishing_identity (
            id INTEGER PRIMARY KEY,
            name TEXT NOT NULL UNIQUE
        ) STRICT
        """
      , parameters = []
      }

    , { statement =
        """
        CREATE TABLE IF NOT EXISTS publishing_identity_users (
            user_id INTEGER NOT NULL REFERENCES user(id),
            publishing_identity_id INTEGER NOT NULL REFERENCES publishing_identity(id),
            role TEXT
        ) STRICT
        """
      , parameters = []
      }
    ]
