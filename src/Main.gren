module Main exposing (main)

import Bytes exposing (Bytes)
import Crypto
import Db
import Dict
import Email exposing (Email)
import Db.Encode
import HttpClient
import HttpServer exposing (Request, ServerError(..), Method(..))
import HttpServer.Response as Response exposing (Response)
import Init
import Json.Decode
import Node exposing (Environment, Program)
import Postmark
import Registry.Db
import Route.Error
import Route.Session
import Stream
import Task exposing (Task)
import Test.E2E.Helper as Helper


main : Program Model Msg
main =
    Node.defineProgram
        { init = init
        , update = update
        , subscriptions = subscriptions
        }


serverConfig : { host : String, port_ : Int }
serverConfig =
    { host = "0.0.0.0"
    , port_ = 3000
    }


-- MODEL


type alias Model =
    { stdout : Stream.Writable Bytes
    , stderr : Stream.Writable Bytes
    , server : Maybe HttpServer.Server
    , db : Db.Connection
    , postmark : Maybe Postmark.Configuration
    , secureContext : Maybe Crypto.SecureContext
    }


init : Environment -> Init.Task { model : Model, command : Cmd Msg }
init env =
    Init.await HttpServer.initialize <| \serverPermission ->
    Init.await HttpClient.initialize <| \httpPerm ->
    Init.awaitTask Node.getEnvironmentVariables <| \envVars ->
        let
            db =
                Helper.initDb httpPerm

            postmark =
                envVars
                    |> Dict.get "POSTMARK_API_TOKEN"
                    |> Maybe.map
                        (\token ->
                            { httpPermission = httpPerm
                            , apiToken = token
                            }
                        )
        in
        Node.startProgram
            { model =
                { stdout = env.stdout
                , stderr = env.stderr
                , server = Nothing
                , db = db
                , secureContext = Nothing
                , postmark = postmark
                }
            , command =
                Cmd.batch
                    [ Registry.Db.migrate db 
                        |> Task.attempt DbMigrationResult
                    , HttpServer.createServer serverPermission serverConfig
                        |> Task.attempt CreateServerResult
                    , Crypto.getSecureContext
                        |> Task.attempt SecureContextResult
                    ]
            }


-- UPDATE


type Msg
    = CreateServerResult (Result HttpServer.ServerError HttpServer.Server)
    | DbMigrationResult (Result Db.Error (Array Int))
    | SecureContextResult (Result {} Crypto.SecureContext)
    | GotRequest { request : HttpServer.Request, response : Response }
    | ResponseReady Response


update : Msg -> Model -> { model : Model, command : Cmd Msg }
update msg model =
    when msg is
        CreateServerResult result ->
            when result is
                Ok server ->
                    { model = { model | server = Just server }
                    , command = 
                        "Server started: http://" ++ serverConfig.host ++ ":" ++ String.fromInt serverConfig.port_
                            |> print model.stdout
                            |> Task.execute
                    }

                Err (ServerError { code, message }) ->
                    { model = model
                    , command = 
                        "Server failed to start: " ++ code ++ "\n" ++ message
                            |> print model.stderr
                            |> Task.execute
                    }

        DbMigrationResult result ->
            when result is
                Ok numChanges ->
                    { model = model
                    , command = Cmd.none
                    }

                Err error ->
                    { model = model
                    , command =
                        -- TODO: real error message
                        "Db failed to migrate: " ++ Debug.toString error
                            |> print model.stderr
                            |> Task.map (\_ -> Node.exitWithCode 1)
                            |> Task.executeCmd
                    }

        SecureContextResult result ->
            when result is
                Ok secureContext ->
                    { model = { model | secureContext = Just secureContext }
                    , command = Cmd.none
                    }

                Err _ ->
                    { model = model
                    , command =
                        "Failed to get secure context"
                            |> print model.stderr
                            |> Task.map (\_ -> Node.exitWithCode 1)
                            |> Task.executeCmd
                    }
                            
        GotRequest { request, response } ->
            { model = model
            , command =
                route model request response
                    |> Task.perform ResponseReady
            }

        ResponseReady response ->
            { model = model
            , command =
                Response.send response
            }


route : Model -> Request -> Response -> Task Never Response
route model request response =
    let
        path =
            request.url.path
                |> String.split "/"
                |> Array.keepIf (\s -> s /= "")

        config =
            { secureContext = model.secureContext
            , postmark = model.postmark
            }
    in
    when config is
        { secureContext = Nothing } ->
            Route.Error.serverError response "Missing secure context."

        { postmark = Nothing } ->
            Route.Error.serverError response "Missing postmark config."

        { postmark = Just postmark, secureContext = Just secureContext } ->
            when { method = request.method, path = path } is

                { method = POST, path = [ "session" ] } ->
                    when getEmail request.body is
                        Just email ->
                            Route.Session.create 
                                { db = model.db
                                , postmark = postmark
                                , secureContext = secureContext
                                , requestData = { email = email }
                                , response = response
                                }

                        Nothing ->
                            Route.Error.invalidRequestData response
                                "Request json did not contain a valid `email` field."

                _ ->
                    Route.Error.notFound response


getEmail : Bytes -> Maybe Email
getEmail bytes =
    bytes
        |> Bytes.toString
        |> Maybe.andThen decodeEmail
        |> Maybe.andThen Email.fromString


decodeEmail : String -> Maybe String
decodeEmail json =
    json
        |> Json.Decode.decodeString emailDecoder
        |> Result.toMaybe


emailDecoder : Json.Decode.Decoder String
emailDecoder =
    Json.Decode.field "email" Json.Decode.string


print : Stream.Writable Bytes -> String -> Task Never {}
print stream string =
    Stream.writeLineAsBytes string stream
        |> Task.map (\_ -> {})
        |> Task.onError (\_ -> Task.succeed {})


-- SUBSCRIPTION


subscriptions : Model -> Sub Msg
subscriptions model =
    when model.server is
        Just server ->
            HttpServer.onRequest server <| \req res -> 
                GotRequest { request = req, response = res }

        Nothing ->
            Sub.none

