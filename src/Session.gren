module Session exposing
    ( Session
    , create
    )


import Bytes.Decode
import Crypto
import Db
import Db.Encode
import Db.Decode
import Email
import Math
import Task exposing (Task)
import Time
import User exposing (User)


type alias Session =
    { created : Time.Posix
    , user : User
    , emailConfirmationCode : String
    , fetchSessionToken : String
    }


create : 
    { db : Db.Connection
    , secureContext : Crypto.SecureContext
    , user : User
    } 
    -> Task Db.Error Session
create { db, user, secureContext } =
    Task.await (generateEmailConfirmationCode secureContext) <| \code ->
    Task.await (Crypto.randomUuidV4 secureContext) <| \uuid2 ->
    Task.await Time.now <| \now ->
        dbInsert db
            { created = now
            , user = user
            , emailConfirmationCode = code
            , fetchSessionToken = uuid2
            }


{-| Generate a short email confirmation code that can be typed by hand.
-}
generateEmailConfirmationCode : Crypto.SecureContext -> Task x String
generateEmailConfirmationCode secureContext =
    Crypto.randomUuidV4 secureContext
        |> Task.map
            (\uuid ->
                uuid
                    |> String.toUpper
                    |> String.takeFirst 8

                    -- 1 and 0 are valid hex characters that could be
                    -- visually confused with another character.
                    |> String.replace "1" "L"
                    |> String.replace "0" "P"
            )


-- DB HELPERS


dbInsert : Db.Connection -> Session -> Task Db.Error Session
dbInsert db session =
    Task.map (\_ -> session) <|
        Db.execute db 
            { statement = 
                """
                insert into session (created, user_id, email_confirmation_code, fetch_session_token)
                values (:created, :user_id, :email_confirmation_code, :fetch_session_token)
                """
            , parameters =
                [ Db.Encode.posix "created" session.created
                , Db.Encode.int "user_id" session.user.id
                , Db.Encode.string "email_confirmation_code" session.emailConfirmationCode
                , Db.Encode.string "fetch_session_token" session.fetchSessionToken
                ]
            }
