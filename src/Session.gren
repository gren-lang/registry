module Session exposing
    ( Session
    , create
    )


import Crypto
import Db
import Db.Encode
import Db.Decode
import Task exposing (Task)
import Time
import User exposing (User)


type alias Session =
    { created : Time.Posix
    , userId : Int
    , emailValidationToken : String
    , fetchSessionToken : String
    }


create : 
    { db : Db.Connection
    , secureContext : Crypto.SecureContext
    , user : User
    } 
    -> Task Db.Error Session
create { db, user, secureContext } =
    Task.await (Crypto.randomUuidV4 secureContext) <| \uuid1 ->
    Task.await (Crypto.randomUuidV4 secureContext) <| \uuid2 ->
    Task.await Time.now <| \now ->
        dbInsert db
            { created = now
            , userId = user.id
            , emailValidationToken = uuid1
            , fetchSessionToken = uuid2
            }


dbInsert : Db.Connection -> Session -> Task Db.Error Session
dbInsert db session =
    Task.map (\_ -> session) <|
        Db.execute db 
            { statement = 
                """
                insert into session (created, user_id, email_validation_token, fetch_session_token)
                values (:created, :user_id, :email_validation_token, :fetch_session_token)
                """
            , parameters =
                [ Db.Encode.posix "created" session.created
                , Db.Encode.int "user_id" session.userId
                , Db.Encode.string "email_validation_token" session.emailValidationToken
                , Db.Encode.string "fetch_session_token" session.fetchSessionToken
                ]
            }
